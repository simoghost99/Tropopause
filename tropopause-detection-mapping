import numpy as np
import netCDF4 as nc
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
import cartopy.feature as cfeature
from datetime import datetime
import time as timemod
import matplotlib.colors as mcolors
from scipy.interpolate import griddata
from scipy.ndimage import gaussian_filter
import geopandas as gpd

# Constants
GRAVITY = 9.80665  # m/s^2
RD = 287.05        # J/(kg*K) - Gas constant for dry air
RKAPPA = 0.2854    # RD/CP for dry air
CP = 1004.0        # J/(kg*K) - Specific heat at constant pressure

# Directory setup
direcInput = "C:/Users/moham/OneDrive/Documents/stage"
direcOutput = "C:/Users/moham/OneDrive/Documents/stage"

# Create a professional colormap for tropopause pressure
colors = ['#000080', '#0000FF', '#0080FF', '#00FFFF', '#80FF80', 
          '#FFFF00', '#FF8000', '#FF0000', '#800000']
cmap = mcolors.LinearSegmentedColormap.from_list('tropopause_cmap', colors, N=256)

# --- CORRECTED Tropopause Detection Functions ---

def detect_tropopause_stability(temp_profile, p_levels_pa):
    """
    Alternative implementation using the exact formula from the documentation.
    Searches from top downward to find the highest tropopause.
    """
    kflev = len(p_levels_pa)
    
    # Find indices for the 70-500 hPa range
    valid_indices = np.where((p_levels_pa >= 7000) & (p_levels_pa <= 50000))[0]
    
    if len(valid_indices) == 0:
        return np.nan
    
    # Iterate from TOP (70 hPa) to BOTTOM (500 hPa)
    for idx in range(len(valid_indices)-1, -1, -1):
        j = valid_indices[idx]
        
        # Check if we have enough levels for the calculation
        if j + 2 >= kflev:
            continue
            
        # Use the exact formula: zstab = pp[j+1] * (pt[j+2] - pt[j]) / (pt[j+1] * (pp[j+2] - pp[j])) + RD * pt[j+1] * 2.5e-4 / (RG * RG)
        numerator = p_levels_pa[j+1] * (temp_profile[j+2] - temp_profile[j])
        denominator = temp_profile[j+1] * (p_levels_pa[j+2] - p_levels_pa[j])
        
        if denominator == 0:
            continue
            
        zstab = numerator / denominator + RD * temp_profile[j+1] * 2.5e-4 / (GRAVITY**2)
        
        if zstab >= RKAPPA:
            trop_pressure = p_levels_pa[j] / 100.0  # Convert to hPa
            
            # Validate the result
            if trop_pressure < 50 or trop_pressure > 500:
                continue
            return trop_pressure
    
    return np.nan

def detect_tropopause_hygropause(q_profile, p_levels_pa):
    """
    Improved hygropause method with better handling of edge cases.
    """
    kflev = len(p_levels_pa)
    
    # Convert q from kg/kg to mg/kg (1 kg/kg = 1,000,000 mg/kg)
    q_mgkg = q_profile * 1e6
    
    # Find indices for the 70-500 hPa range
    valid_indices = np.where((p_levels_pa >= 7000) & (p_levels_pa <= 50000))[0]
    
    if len(valid_indices) == 0:
        return np.nan
    
    # Iterate from top (70 hPa) to bottom (500 hPa) to find the HIGHEST level that meets criteria
    for idx in range(len(valid_indices)-1, -1, -1):
        j = valid_indices[idx]
        
        # Check if we have at least 2 levels below the current level
        if j + 2 >= kflev:
            continue
            
        # Check the hygropause criteria
        current_q = q_mgkg[j]
        two_below_q = q_mgkg[j + 2]
        
        if current_q > 3.0 and two_below_q > 5.0:
            trop_pressure = p_levels_pa[j] / 100.0  # Convert to hPa
            
            # Validate the result
            if trop_pressure < 50 or trop_pressure > 500:
                continue  # Try next level instead of returning NaN
            return trop_pressure
    
    # If no level found, return NaN
    return np.nan

def detect_tropopause_hybrid(temp_profile, q_profile, p_levels_pa):
    """
    Hybrid method: uses both stability and hygropause criteria.
    Returns the higher tropopause (lower pressure) if both are found.
    """
    p_stab = detect_tropopause_stability(temp_profile, p_levels_pa)
    p_hygro = detect_tropopause_hygropause(q_profile, p_levels_pa)
    
    # If both found, choose the higher tropopause (lower pressure)
    if not np.isnan(p_stab) and not np.isnan(p_hygro):
        return min(p_stab, p_hygro)
    elif not np.isnan(p_stab):
        return p_stab
    elif not np.isnan(p_hygro):
        return p_hygro
    else:
        return np.nan

# Open the NetCDF file
print("Opening the NetCDF file...")
with nc.Dataset(direcInput+"/629f42bac50cf310898d868e4fd1d664.nc", mode='r') as f:
    # Read data
    lat = f.variables["latitude"][:] 
    lon = f.variables["longitude"][:] 
    time = f.variables["valid_time"][:]
    p_levels = f.variables["pressure_level"][:]  # Pressure levels in hPa
    p_levels_pa = p_levels * 100  # Convert to Pa

    print(f"Pressure levels available: {p_levels} hPa")

    # Convert longitudes
    lon_corrected = np.where(lon > 180, lon - 360, lon)
    
    # Exact region boundaries as requested
    lat_min, lat_max = 20, 55   # Exactly 20°N to 55°N
    lon_min, lon_max = -30, 30  # Exactly 30°W to 30°E
    
    lat_indices = np.where((lat >= lat_min) & (lat <= lat_max))[0]
    lon_indices = np.where((lon_corrected >= lon_min) & (lon_corrected <= lon_max))[0]
    
    lat_region = lat[lat_indices]
    lon_region = lon_corrected[lon_indices]

    print(f"Region: {len(lat_region)}x{len(lon_region)} points")
    print(f"Exact range: {lat_region.min():.1f}°N to {lat_region.max():.1f}°N, {lon_region.min():.1f}°E to {lon_region.max():.1f}°E")

    methods = ['stability', 'hygropause', 'hybrid']
    
    for i in range(min(16, len(time))):
        start_time = timemod.time()
        print(f"\nProcessing timestep {i+1}...")

        # Extract only the defined region
        temp_data = f.variables["t"][i, :, lat_indices[0]:lat_indices[-1]+1, lon_indices[0]:lon_indices[-1]+1]
        z_data = f.variables["z"][i, :, lat_indices[0]:lat_indices[-1]+1, lon_indices[0]:lon_indices[-1]+1] / GRAVITY
        q_data = f.variables["q"][i, :, lat_indices[0]:lat_indices[-1]+1, lon_indices[0]:lon_indices[-1]+1]
        pv_data = f.variables["pv"][i, :, lat_indices[0]:lat_indices[-1]+1, lon_indices[0]:lon_indices[-1]+1] * 1e6

        for method in methods:
            print(f"Processing {method} method...")

            tropopause_p = np.full((len(lat_region), len(lon_region)), np.nan)
            valid_count = 0

            for iy in range(len(lat_region)):
                for ix in range(len(lon_region)):
                    temp_profile = temp_data[:, iy, ix]
                    q_profile = q_data[:, iy, ix]

                    if np.all(np.isfinite(temp_profile)) and np.all(np.isfinite(q_profile)):
                        if method == 'stability':
                            p_trop = detect_tropopause_stability(temp_profile, p_levels_pa)
                        elif method == 'hygropause':
                            p_trop = detect_tropopause_hygropause(q_profile, p_levels_pa)
                        elif method == 'hybrid':
                            p_trop = detect_tropopause_hybrid(temp_profile, q_profile, p_levels_pa)

                        if not np.isnan(p_trop) and 50 < p_trop < 500:
                            tropopause_p[iy, ix] = p_trop
                            valid_count += 1

            print(f"Found {valid_count} valid points")

            if valid_count < 30:
                print(f"Skipping {method} method - not enough valid points")
                continue
            
            # Prepare for interpolation
            lon_grid, lat_grid = np.meshgrid(lon_region, lat_region)
            valid_mask = ~np.isnan(tropopause_p)
            
            if np.sum(valid_mask) == 0:
                print(f"No valid points for interpolation in {method} method")
                continue
                
            valid_points = np.column_stack((lon_grid[valid_mask], lat_grid[valid_mask]))
            valid_values = tropopause_p[valid_mask]
            
            # Create interpolation grid - exactly matching the region boundaries
            lon_fine = np.linspace(lon_min, lon_max, 120)  # Higher resolution
            lat_fine = np.linspace(lat_min, lat_max, 120)
            lon_fine_grid, lat_fine_grid = np.meshgrid(lon_fine, lat_fine)
            
            # Interpolate and smooth
            p_interp = griddata(valid_points, valid_values, 
                               (lon_fine_grid, lat_fine_grid), method='cubic')
            p_interp = gaussian_filter(p_interp, sigma=1.2)
            p_interp = np.clip(p_interp, 80, 350)

            # Create professional meteorological plot
            fig = plt.figure(figsize=(16, 12))
            ax = plt.axes(projection=ccrs.PlateCarree())
        
            # Set EXACT map extent - no margins
            ax.set_extent([lon_min, lon_max, lat_min, lat_max], crs=ccrs.PlateCarree())
        
            # Add coastlines
            ax.add_feature(cfeature.COASTLINE.with_scale('50m'), linewidth=0.8, edgecolor='black')

            # Load Morocco shapefile
            try:
                morocco = gpd.read_file(r"C:/Users/moham/OneDrive/Documents/stage/Morocco_ADM0_simplified.simplified.geojson")
                # Draw Morocco outline
                for geometry in morocco["geometry"]:
                    ax.add_geometries(
                        [geometry],
                        crs=ccrs.PlateCarree(),
                        facecolor='none',
                        edgecolor='black',
                        linewidth=1.5,
                        zorder=5
                    )
            except Exception as e:
                print(f"Could not load Morocco shapefile: {e}")
           
            # Add gridlines with exact boundaries
            gl = ax.gridlines(crs=ccrs.PlateCarree(), draw_labels=True,
                             linewidth=0.5, color='gray', alpha=0.7, linestyle='--')
            gl.top_labels = False
            gl.right_labels = False
            gl.left_labels = True
            gl.bottom_labels = True
            gl.xlocator = plt.FixedLocator(np.arange(-30, 31, 10))
            gl.ylocator = plt.FixedLocator(np.arange(20, 56, 5))
            gl.xlabel_style = {'size': 10, 'color': 'black'}
            gl.ylabel_style = {'size': 10, 'color': 'black'}

            # Plot filled contours
            levels = np.arange(80, 351, 10)
            cs = ax.contourf(lon_fine_grid, lat_fine_grid, p_interp,
                           levels=levels, cmap=cmap, transform=ccrs.PlateCarree(),
                           alpha=0.8, extend='both')
            
            # Plot contour lines
            contour_lines = ax.contour(lon_fine_grid, lat_fine_grid, p_interp,
                                     levels=levels, colors='black', linewidths=0.8,
                                     transform=ccrs.PlateCarree(), alpha=0.7)
            
            # Add contour labels (every other level)
            plt.clabel(contour_lines, levels=levels[::2], fmt='%d', fontsize=9,
                      colors='black', inline=True, inline_spacing=5)
            
            # Add time information
            time_val = time[i]
            time_dt = datetime.fromtimestamp(time_val)
            time_str = time_dt.strftime('%Y-%m-%d %H:%M UTC')
            
            method_name = method.capitalize()
            if method == 'hygropause':
                method_name = 'Hygropause'
            
            # Professional title
            plt.title(f'Tropopause Pressure Analysis - {method_name} Method\n{time_str}',
                     fontsize=16, fontweight='bold', pad=20)
            
            # Add colorbar
            cbar = plt.colorbar(cs, ax=ax, orientation='horizontal', 
                               pad=0.08, aspect=40, shrink=0.8)
            cbar.set_label('Tropopause Pressure (hPa)', fontsize=12, fontweight='bold')
            cbar.ax.tick_params(labelsize=10)
            
            # Add scale and credit
            plt.text(0.02, 0.02, 'Data: ECMWF ERA5', transform=ax.transAxes,
                    fontsize=9, color='gray', alpha=0.7)
            
            # Add exact latitude/longitude boundaries
            plt.text(0.98, 0.02, f'Lon: {lon_min}°E to {lon_max}°E\nLat: {lat_min}°N to {lat_max}°N',
                    transform=ax.transAxes, fontsize=9, color='gray', alpha=0.7,
                    horizontalalignment='right')
            
            # Save high-quality figure
            plt.savefig(direcOutput + f"/tropopause_{method}_{i:02d}.png", 
                       dpi=300, bbox_inches='tight', facecolor='white')
            plt.show()
            plt.close()
            
            end_time = timemod.time()
            print(f"{method_name} map {i+1} generated in {end_time - start_time:.1f}s")
            

print("All tropopause maps generated successfully!")
