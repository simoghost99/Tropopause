# -*- coding: utf-8 -*-
"""
Tropopause analysis with PV, Thermal tropopause, and background (wind and temperature)
"""

import numpy as np
import netCDF4 as nc
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D
import os
import time

# -------------------------
# Constants
# -------------------------
GRAVITY = 9.80665
RD = 287.05
CP = 1004.0
RKAPPA = RD / CP
g = 9.81

# -------------------------
# Paths
# -------------------------
direcInput = "C:/Users/moham/OneDrive/Documents/stage"
direcOutput = "C:/Users/moham/OneDrive/Documents/stage"
nc_file = os.path.join(direcInput, "6d772be982907b488c8caefd91616826.nc")

os.makedirs(direcOutput, exist_ok=True)

# =========================
# Thermal tropopause detection
# =========================
def find_thermal_tropopause_corrected(temp_zm_tm, z_height, pp_pa):
    """
    Corrected thermal tropopause detection with proper lapse rate calculation
    """
    nlev, nlat = temp_zm_tm.shape
    pTropopauseWMO = np.full(nlat, np.nan)
    
    # Skip levels below 500 hPa
    valid_levels = pp_pa <= 50000
    valid_indices = np.where(valid_levels)[0]
    
    # Calculate lapse rates correctly
    # Lapse rate = -dT/dz (temperature decrease with height)
    # We need to calculate between adjacent levels
    lapse_rates = np.full_like(temp_zm_tm, np.nan)
    
    for j in range(nlev - 1):
        dz = z_height[j + 1, :] - z_height[j, :]  # Height difference (km)
        dT = temp_zm_tm[j + 1, :] - temp_zm_tm[j, :]  # Temperature difference (K)
        
        # Avoid division by zero
        valid_dz = dz != 0
        lapse_rates[j, valid_dz] = -dT[valid_dz] / dz[valid_dz]  # K/km
        
        # Check for unrealistic values
        unrealistic = np.where((lapse_rates[j, :] < -20) | (lapse_rates[j, :] > 20))[0]
        if len(unrealistic) > 0:
            # Reset unrealistic values
            lapse_rates[j, unrealistic] = np.nan
    
    # Check for lapse rate <= 2.0 K/km (WMO criterion)
    for j in valid_indices:
        if j >= nlev - 1:
            continue
            
        # Find latitudes where lapse rate condition is met
        lapse_condition = lapse_rates[j, :] <= 2.0
        
        # For these latitudes, check average lapse rate over next 2 km
        for lat_idx in np.where(lapse_condition)[0]:
            if not np.isnan(pTropopauseWMO[lat_idx]):
                continue
                
            # Find levels within 2 km above current level
            current_z = z_height[j, lat_idx]
            target_z = current_z + 2.0  # 2 km above
            
            # Find levels above current level within 2 km range
            levels_in_range = []
            for k in range(j, nlev):
                if z_height[k, lat_idx] > target_z:
                    break
                levels_in_range.append(k)
            
            if len(levels_in_range) > 1:
                # Calculate average lapse rate for these levels
                valid_lapse_rates = []
                for k in levels_in_range:
                    if k < nlev - 1 and not np.isnan(lapse_rates[k, lat_idx]):
                        # Only include physically realistic lapse rates
                        if -20 < lapse_rates[k, lat_idx] < 20:
                            valid_lapse_rates.append(lapse_rates[k, lat_idx])
                
                if len(valid_lapse_rates) > 0:
                    avg_lapse = np.mean(valid_lapse_rates)
                    
                    # Only accept physically realistic average lapse rates
                    if -10 < avg_lapse <= 2.0:
                        pTropopauseWMO[lat_idx] = pp_pa[j]
    
    # Debug: Count how many latitudes have valid tropopause
    valid_count = np.sum(~np.isnan(pTropopauseWMO))
    print(f"Thermal tropopause found at {valid_count} of {nlat} latitudes")
    
    return pTropopauseWMO

# =========================
# Geopotential height calculation
# =========================
def calculate_geopotential_height_vectorized(temp_zm_tm, pp_pa):
    """
    Vectorized geopotential height calculation
    """
    nlev, nlat = temp_zm_tm.shape
    z_height = np.zeros((nlev, nlat))
    
    # Start from the top level
    H = RD * temp_zm_tm[0, :] / g
    z_height[0, :] = -H * np.log(pp_pa[0] / 100000)
    
    # Vectorized integration downward
    for nlev_idx in range(1, nlev):
        T_avg = (temp_zm_tm[nlev_idx-1, :] + temp_zm_tm[nlev_idx, :]) / 2
        dz = (RD * T_avg / g) * np.log(pp_pa[nlev_idx-1] / pp_pa[nlev_idx])
        z_height[nlev_idx, :] = z_height[nlev_idx-1, :] + dz
    
    # Convert to km
    z_height /= 1000
    
    return z_height

# =========================
# Optimized data processing
# =========================
def process_variable_optimized(dataset, var_name, time_chunk_size=5, lat_chunk_size=30):
    """
    Optimized variable processing with larger chunks for better performance
    """
    # Check which dimension name exists in the file
    if 'valid_time' in dataset.dimensions:
        ntime = dataset.dimensions['valid_time'].size
    elif 'time' in dataset.dimensions:
        ntime = dataset.dimensions['time'].size
    else:
        raise ValueError("No time dimension found in the dataset")
        
    nlat = dataset.dimensions['latitude'].size
    nlev = dataset.dimensions['pressure_level'].size
    
    # Initialize array for zonal mean
    var_zm_tm = np.zeros((nlev, nlat), dtype=np.float32)
    
    # Process data in time and latitude chunks
    for time_i in range(0, ntime, time_chunk_size):
        time_end = min(time_i + time_chunk_size, ntime)
        
        for lat_i in range(0, nlat, lat_chunk_size):
            lat_end = min(lat_i + lat_chunk_size, nlat)
            
            try:
                # Read chunk of data
                var_chunk = dataset.variables[var_name][time_i:time_end, :, lat_i:lat_end, :]
                
                # Calculate zonal mean for this chunk
                var_zm_chunk = np.mean(var_chunk, axis=(0, 3))
                
                # Accumulate results with proper weighting
                chunk_weight = (time_end - time_i) / ntime
                var_zm_tm[:, lat_i:lat_end] += var_zm_chunk * chunk_weight
                
            except Exception as e:
                print(f"Error processing {var_name}: {e}")
                continue
    
    return var_zm_tm

# =========================
# Main - PV AND THERMAL ONLY
# =========================
if __name__ == "__main__":
    start_time = time.time()
    
    print("Opening NetCDF:", nc_file)
    try:
        with nc.Dataset(nc_file, mode='r') as f:
            # Read basic dimensions
            lat = f.variables["latitude"][:]
            plev_hpa = f.variables["pressure_level"][:]
            pp_pa = plev_hpa * 100.0
            
            print("Reading and processing data with optimized chunks...")
            
            # Process variables with optimized chunk sizes
            print("Processing u variable...")
            u_zm_tm = process_variable_optimized(f, "u", time_chunk_size=5, lat_chunk_size=30)
            
            print("Processing t variable...")
            temp_zm_tm = process_variable_optimized(f, "t", time_chunk_size=5, lat_chunk_size=30)
            
            print("Processing pv variable...")
            pv_zm_tm = process_variable_optimized(f, "pv", time_chunk_size=5, lat_chunk_size=30)
            pv_zm_tm *= 1e6  # convert PV to PVU
            
            nlev_len, ny_len = temp_zm_tm.shape
            
            # Calculate geopotential height for thermal tropopause
            print("Calculating geopotential height...")
            z_height = calculate_geopotential_height_vectorized(temp_zm_tm, pp_pa)
            
            print("Calculating thermal tropopause...")
            
            # Calculate thermal tropopause only
            pThermal = find_thermal_tropopause_corrected(temp_zm_tm, z_height, pp_pa)
            
            thermal_valid = np.sum(~np.isnan(pThermal))
            print(f"Thermal tropopause found at {thermal_valid} of {ny_len} latitudes")
            
            # Prepare for plotting
            paxis = np.log10(pp_pa / 100)  # log10 of pressure in hPa
            ptop = 0.8  # log10(10 hPa)
            pbot = 3.0  # log10(1000 hPa)
            
            # Filter PV values to remove illogical values at high and low pressures
            for nlev in range(nlev_len): 
                for ny in range(ny_len):
                    if pp_pa[nlev] > 50000: 
                        pv_zm_tm[nlev, ny] = 0.0
            
            print("Creating plot...")
            
            # ---------- PLOT ----------
            plt.figure(figsize=(12, 7))
            plt.axis([lat[-1], lat[0] + 0.1, pbot, ptop])
            
            # Create legend
            legend_elements = [
                Line2D([0], [0], color='green', lw=4, label='Dynamical Tropopause (PV=2)'),
                Line2D([0], [0], marker='o', color='red', lw=0, label='Thermal Tropopause',
                       markersize=8, markeredgewidth=2)
            ]
            plt.legend(handles=legend_elements, loc='upper right', fontsize=10, framealpha=0.8, facecolor='white')
            
            # Plot zonal wind contours
            CS = plt.contour(lat, paxis, u_zm_tm, linewidths=1, levels=[5,10,15,25,30,35,45,50,55,65,70,75], 
                             linestyles='solid', colors='black')
            CS = plt.contour(lat, paxis, u_zm_tm, linewidths=4, levels=[20,40,60,80], 
                             linestyles='solid', colors='black')
            plt.clabel(CS, fontsize=12, inline=1, fmt='%1.0f')
            
            CS = plt.contour(lat, paxis, u_zm_tm, linewidths=1, levels=[-70,-65,-55,-50,-45,-35,-30,-25,-15,-10,-5], 
                             linestyles='dashed', colors='black')
            CS = plt.contour(lat, paxis, u_zm_tm, linewidths=2, levels=[-60,-40,-20], 
                             linestyles='dashed', colors='black')
            plt.clabel(CS, fontsize=12, inline=1, fmt='%1.0f')
            
            # Plot temperature contours
            temp_c = temp_zm_tm - 273.16
            CS = plt.contour(lat, paxis, temp_c, linewidths=1, levels=[10,20,30,40], 
                             linestyles='solid', colors='red')
            CS = plt.contour(lat, paxis, temp_c, linewidths=3, levels=[0], 
                             linestyles='dashed', colors='c')
            plt.clabel(CS, fontsize=14, inline=1, fmt='%1.0f')
            
            CS = plt.contour(lat, paxis, temp_c, linewidths=1, levels=[-70,-50,-40,-30,-20,-10], 
                             linestyles='solid', colors='blue')
            CS = plt.contour(lat, paxis, temp_c, linewidths=3, levels=[-80,-60], 
                             linestyles='solid', colors='blue')
            plt.clabel(CS, fontsize=14, inline=1, fmt='%1.0f')
            
            # Fill temperature regions
            plt.contourf(lat, paxis, temp_c, levels=[-120,-80.1], colors='mediumorchid', alpha=0.7) 
            plt.contourf(lat, paxis, temp_c, levels=[-79.9,-60], colors='lightskyblue', alpha=0.7) 
            plt.contourf(lat, paxis, temp_c, levels=[10,60], colors='lightsalmon', alpha=0.7)  
            plt.contourf(lat, paxis, temp_c, levels=[-60,0], colors='lightcyan', alpha=0.7) 
            
            # DRAW THE DYNAMICAL TROPOPAUSE (PV=2 contour)
            CP = plt.contour(lat, paxis, pv_zm_tm, levels=[-2, +2], linestyles='solid', 
                             linewidths=7.0, colors='green')
            plt.clabel(CP, fontsize=12, inline=1, fmt='%1.0f', colors='green')
            
            # Plot thermal tropopause only
            valid_lat_mask = np.abs(lat) < 88.0
            
            # Thermal tropopause
            thermal_mask = valid_lat_mask & ~np.isnan(pThermal)
            plt.plot(lat[thermal_mask], np.log10(pThermal[thermal_mask]/100), "o", 
                     markersize=6, color='red', alpha=0.8)
            
            # Final plot formatting
            plt.xticks(np.arange(lat[-1], lat[0] + 0.1, 15), fontsize=15)
            plt.yticks(np.arange(pbot, ptop, -1), fontsize=15)
            
            ax = plt.gca()
            ax.axes.yaxis.set_ticklabels([])
            
            # Add pressure labels
            pressure_labels = [
                (3, "1000", lat[-1]-14),
                (2.02, "100", lat[-1]-11),
                (1.02, "10", lat[-1]-8),
                (2.497, "300", lat[-1]-11),
                (1.497, "30", lat[-1]-8),
                (2.72, "500", lat[-1]-11),
                (1.72, "50", lat[-1]-8),
                (2.32, "200", lat[-1]-11),
                (1.32, "20", lat[-1]-8)
            ]
            
            for y, text, x_pos in pressure_labels:
                plt.text(x_pos, y, text, fontsize=15)
            
            # Title and labels
            plt.title('Monthly/zonal-mean zonal wind (m/s), temperature (C)\n'
                      'PV (green), Thermal (red)', 
                      fontsize=10)
            
            plt.text(80, 3.20, "ERA5", fontsize=8)
            plt.text(80, 3.25, "Tropopause Analysis", fontsize=8)
            
            plt.xlabel('latitude [degrees north]', fontsize=16)
            plt.text(lat[-1]-20, 2.3, 'pressure (hPa)', rotation=90, va='center', fontsize=16)
            
            # Save and show
            outfile = os.path.join(direcOutput, "tropopause_pv_thermal_comparison.png")
            plt.savefig(outfile, dpi=300, bbox_inches='tight')
            plt.show()
            plt.close()
            
            elapsed_time = time.time() - start_time
            print(f"Saved: {outfile}")
            print(f"Execution time: {elapsed_time:.2f} seconds")

    except Exception as e:
        print(f"Error opening or processing file: {e}")
        import traceback
        traceback.print_exc()

    print("Processing completed.")
