import numpy as np
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
from netCDF4 import Dataset
import os

# Constants
Rd = 287.04  # J/kg/K
cp = 1005.0  # J/kg/K
g = 9.80665  # m/s²
N0_sq = 2.5e-4  # s⁻² (Brunt-Väisälä frequency squared threshold)

def load_era5_data(filepath):
    nc = Dataset(filepath, 'r')
    print("Available variables:", list(nc.variables.keys()))
    
    # Get variables
    data = {
        'pressure_levels': nc.variables['pressure_level'][:].astype(float) * 100,  # Convert to Pa
        'lat': nc.variables['latitude'][:],
        'lon': nc.variables['longitude'][:],
        't': nc.variables['t'][0],  # Temperature [K]
        'q': nc.variables['q'][0]   # Specific humidity [kg/kg]
    }
    nc.close()
    
    # Ensure descending order
    if data['pressure_levels'][0] < data['pressure_levels'][-1]:
        data['pressure_levels'] = data['pressure_levels'][::-1]
        data['t'] = data['t'][::-1, :, :]
        data['q'] = data['q'][::-1, :, :]
    
    print("\nPressure levels (hPa):", data['pressure_levels'][:5]/100, "...", data['pressure_levels'][-5:]/100)
    return data

def debug_criterion(t_profile, p_levels):
    """Detailed breakdown of the stability criterion calculation"""
    print("\n=== Criterion Calculation Breakdown ===")
    print("Level (hPa) | Temp (K) | dT/dP (K/Pa) | Term1 (P/T*dT/dP) | Term2 (Rd*T/g²*N0²) | Term3 (Rd/cp) | Criterion")
    
    # Calculate derivatives
    dt_dp = np.gradient(t_profile, p_levels)
    
    for i in range(len(p_levels)):
        term1 = (1/t_profile[i]) * dt_dp[i]
        term2 = (Rd * t_profile[i]) / (g**2) * N0_sq
        term3 = Rd/cp
        criterion = term1 + term2 - term3
        
        print(f"{p_levels[i]/100:10.1f} | {t_profile[i]:7.1f} | {dt_dp[i]:11.3e} | "
              f"{term1:17.3e} | {term2:19.3e} | {term3:10.3e} | {criterion:9.3e}")

def calculate_tropopause(t, p_levels, lat, lon):
    """Corrected implementation of Santer et al. (2004) method"""
    # Focus on 70-500 hPa range (7000-50000 Pa)
    p_mask = (p_levels <= 50000) & (p_levels >= 7000)
    p_sub = p_levels[p_mask]
    t_sub = t[p_mask, :, :]
    
    # Calculate dT/dp using central differences
    dt_dp = np.gradient(t_sub, p_sub, axis=0)
    
    # Calculate criterion (Eq. 6.79) with corrected formulation
    with np.errstate(invalid='ignore'):
        # Original paper uses θ (potential temperature) gradient
        # We'll approximate as (1/θ)(dθ/dp) ≈ (1/T)(dT/dp) - (Rd/cp)(1/p)
        theta_grad = (1/t_sub) * dt_dp - (Rd/cp)/p_sub[:,None,None]
        criterion = theta_grad + (Rd * t_sub)/g**2 * N0_sq
    
    # Find tropopause (first level from top where criterion ≥ -0.01)
    trop_p = np.full(t.shape[1:], np.nan)
    for i in range(t.shape[1]):
        for j in range(t.shape[2]):
            valid = np.where(criterion[:,i,j] >= -0.01)[0]  # Slightly relaxed threshold
            if len(valid) > 0:
                trop_p[i,j] = p_sub[valid[0]]
    
    # Apply physical constraints
    trop_p = np.where((trop_p/100 > 50) & (trop_p/100 < 400), trop_p, np.nan)
    
    # If still no detection, use WMO method as fallback
    if np.all(np.isnan(trop_p)):
        print("Using WMO fallback method")
        height = -7.0 * np.log(p_levels/1000.0)  # Approximate height in km
        for i in range(t.shape[1]):
            for j in range(t.shape[2]):
                t_profile = t[:,i,j]
                lapse_rate = -np.gradient(t_profile, height) * 1000  # K/km
                for k in range(len(lapse_rate)):
                    if lapse_rate[k] <= 2.0 and p_levels[k] < 40000:  # Below 400 hPa
                        trop_p[i,j] = p_levels[k]
                        break
    
    return trop_p/100  # Convert to hPa

def calculate_hygropause(q, p_levels):
    """Calculate hygropause from specific humidity gradient"""
    grad_q = np.abs(np.gradient(q, p_levels, axis=0))
    return p_levels[np.argmin(grad_q, axis=0)]

def process_data(data):
    """Process data with both methods"""
    p_hpa = data['pressure_levels']/100
    
    print("\nCalculating tropopause using Santer et al. (2004) method...")
    trop = calculate_tropopause(data['t'], data['pressure_levels'], data['lat'], data['lon'])
    hygro = calculate_hygropause(data['q'], p_hpa)
    
    # Apply physical constraints
    hygro = np.where((hygro>50)&(hygro<400), hygro, np.nan)
    trop = np.where((trop>50)&(trop<400), trop, np.nan)
    
    return {
        'hygropause': hygro,
        'tropopause': trop,
        'lat': data['lat'],
        'lon': data['lon']
    }

def plot_map(data, lats, lons, title):
    """Plot with your exact style"""
    fig = plt.figure(figsize=(16,8))
    ax = plt.axes(projection=ccrs.Robinson())
    
    mesh = ax.pcolormesh(lons, lats, np.ma.masked_invalid(data),
                        transform=ccrs.PlateCarree(),
                        cmap='viridis',
                        vmin=50, vmax=300)
    
    ax.coastlines(linewidth=0.5)
    ax.gridlines(draw_labels=True)
    plt.colorbar(mesh, ax=ax, label='Pressure (hPa)', pad=0.02)
    plt.title(title, pad=20)
    plt.show()

if __name__ == "__main__":
    era5_file = r"C:/Users/moham/OneDrive/Documents/stage/98a4d3ee3b3b8aa12699f1286ad0843f.nc"
    
    try:
        print("Loading data...")
        era5 = load_era5_data(era5_file)
        
        print("\nProcessing data...")
        results = process_data(era5)
        
        print("\nPlotting results...")
        plot_map(results['hygropause'], results['lat'], results['lon'],
                "Hygropause Pressure")
        plot_map(results['tropopause'], results['lat'], results['lon'],
                "Tropopause Pressure (Santer et al. 2004)")
        
        print("\n=== Final Statistics ===")
        print(f"Hygropause range: {np.nanmin(results['hygropause']):.1f}-{np.nanmax(results['hygropause']):.1f} hPa")
        print(f"Tropopause range: {np.nanmin(results['tropopause']):.1f}-{np.nanmax(results['tropopause']):.1f} hPa")
        
    except Exception as e:
        print(f"\nError: {str(e)}")
