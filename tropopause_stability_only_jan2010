# -*- coding: utf-8 -*-
"""
Optimized combined tropopause analysis with stability and thermal methods
"""

import numpy as np
import netCDF4 as nc
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D
import os
import time

# -------------------------
# Constants
# -------------------------
GRAVITY = 9.80665
RD = 287.05
CP = 1004.0
RKAPPA = RD / CP
g = 9.81

# -------------------------
# Paths
# -------------------------
direcInput = "C:/Users/moham/OneDrive/Documents/stage"
direcOutput = "C:/Users/moham/OneDrive/Documents/stage"
nc_file = os.path.join(direcInput, "6d772be982907b488c8caefd91616826.nc")

os.makedirs(direcOutput, exist_ok=True)

# =========================
# Vectorized stability tropopause detection
# =========================
def find_tropopause_stability(temp_zm_tm, pp_pa):
    """
    Optimized vectorized stability tropopause detection
    """
    nlev, nlat = temp_zm_tm.shape
    
    # Sort pressure levels (top to bottom)
    sort_idx = np.argsort(pp_pa)
    pp_tb = pp_pa[sort_idx]
    temp_tb = temp_zm_tm[sort_idx, :]
    
    # Initialize results
    tropopause_pressures = np.full(nlat, np.nan)
    
    # Find valid pressure range (70-500 hPa)
    valid_p_mask = (pp_tb >= 7000) & (pp_tb <= 50000)
    valid_indices = np.where(valid_p_mask)[0]
    
    # Precompute pressure differences
    pp_diff = np.zeros_like(pp_tb)
    pp_diff[1:-1] = pp_tb[2:] - pp_tb[:-2]
    
    for j in valid_indices:
        if j < 1 or j > nlev-2:
            continue
            
        # Vectorized stability calculation
        dT_dp = (temp_tb[j+1, :] - temp_tb[j-1, :]) / pp_diff[j]
        stability_criterion = (pp_tb[j] / temp_tb[j, :]) * dT_dp + (RD * temp_tb[j, :] / (GRAVITY*GRAVITY)) * 2.5e-4
        
        # Update where criterion is met and not already set
        mask = (stability_criterion >= RD/CP) & np.isnan(tropopause_pressures)
        tropopause_pressures[mask] = pp_tb[j]
    
    return tropopause_pressures

# =========================
# Corrected thermal tropopause detection
# =========================
def find_thermal_tropopause_corrected(temp_zm_tm, z_height, pp_pa):
    """
    Corrected thermal tropopause detection with proper lapse rate calculation
    """
    nlev, nlat = temp_zm_tm.shape
    pTropopauseWMO = np.full(nlat, np.nan)
    
    # Skip levels below 500 hPa
    valid_levels = pp_pa <= 50000
    valid_indices = np.where(valid_levels)[0]
    
    # Calculate lapse rates correctly
    # Lapse rate = -dT/dz (temperature decrease with height)
    # We need to calculate between adjacent levels
    lapse_rates = np.full_like(temp_zm_tm, np.nan)
    
    for j in range(nlev - 1):
        dz = z_height[j + 1, :] - z_height[j, :]  # Height difference (km)
        dT = temp_zm_tm[j + 1, :] - temp_zm_tm[j, :]  # Temperature difference (K)
        
        # Avoid division by zero
        valid_dz = dz != 0
        lapse_rates[j, valid_dz] = -dT[valid_dz] / dz[valid_dz]  # K/km
        
        # Debug: Check for unrealistic values
        unrealistic = np.where((lapse_rates[j, :] < -20) | (lapse_rates[j, :] > 20))[0]
        if len(unrealistic) > 0:
            # Reset unrealistic values
            lapse_rates[j, unrealistic] = np.nan
    
    # Check for lapse rate <= 2.0 K/km (WMO criterion)
    for j in valid_indices:
        if j >= nlev - 1:
            continue
            
        # Find latitudes where lapse rate condition is met
        lapse_condition = lapse_rates[j, :] <= 2.0
        
        # For these latitudes, check average lapse rate over next 2 km
        for lat_idx in np.where(lapse_condition)[0]:
            if not np.isnan(pTropopauseWMO[lat_idx]):
                continue
                
            # Find levels within 2 km above current level
            current_z = z_height[j, lat_idx]
            target_z = current_z + 2.0  # 2 km above
            
            # Find levels above current level within 2 km range
            levels_in_range = []
            for k in range(j, nlev):
                if z_height[k, lat_idx] > target_z:
                    break
                levels_in_range.append(k)
            
            if len(levels_in_range) > 1:
                # Calculate average lapse rate for these levels
                valid_lapse_rates = []
                for k in levels_in_range:
                    if k < nlev - 1 and not np.isnan(lapse_rates[k, lat_idx]):
                        # Only include physically realistic lapse rates
                        if -20 < lapse_rates[k, lat_idx] < 20:
                            valid_lapse_rates.append(lapse_rates[k, lat_idx])
                
                if len(valid_lapse_rates) > 0:
                    avg_lapse = np.mean(valid_lapse_rates)
                    
                    # Only accept physically realistic average lapse rates
                    if -10 < avg_lapse <= 2.0:
                        pTropopauseWMO[lat_idx] = pp_pa[j]
                        print(f"Thermal tropopause found at lat {lat_idx}: {pp_pa[j]/100:.1f} hPa, avg lapse: {avg_lapse:.2f} K/km")
    
    # Debug: Count how many latitudes have valid tropopause
    valid_count = np.sum(~np.isnan(pTropopauseWMO))
    print(f"Thermal tropopause found at {valid_count} of {nlat} latitudes")
    
    return pTropopauseWMO

# =========================
# Corrected geopotential height calculation
# =========================
def calculate_geopotential_height_corrected(temp_zm_tm, pp_pa):
    """
    Corrected geopotential height calculation
    """
    nlev, nlat = temp_zm_tm.shape
    z_height = np.zeros((nlev, nlat))
    
    # Start from the top level (lowest pressure)
    # Use the hypsometric equation: z2 - z1 = (R * T_avg / g) * ln(p1/p2)
    
    # For the top level, use a reasonable estimate
    z_height[0, :] = 0  # Start at 0 km for the top level
    
    # Integrate downward
    for i in range(1, nlev):
        # Average temperature between levels
        T_avg = (temp_zm_tm[i-1, :] + temp_zm_tm[i, :]) / 2
        
        # Height difference using hypsometric equation
        dz = (RD * T_avg / g) * np.log(pp_pa[i-1] / pp_pa[i])
        
        # Convert to km and accumulate
        z_height[i, :] = z_height[i-1, :] + dz / 1000
    
    return z_height

# =========================
# Optimized geopotential height calculation
# =========================
def calculate_geopotential_height_vectorized(temp_zm_tm, pp_pa):
    """
    Vectorized geopotential height calculation
    """
    nlev, nlat = temp_zm_tm.shape
    z_height = np.zeros((nlev, nlat))
    
    # Start from the top level
    H = RD * temp_zm_tm[0, :] / g
    z_height[0, :] = -H * np.log(pp_pa[0] / 100000)
    
    # Vectorized integration downward
    for nlev_idx in range(1, nlev):
        T_avg = (temp_zm_tm[nlev_idx-1, :] + temp_zm_tm[nlev_idx, :]) / 2
        dz = (RD * T_avg / g) * np.log(pp_pa[nlev_idx-1] / pp_pa[nlev_idx])
        z_height[nlev_idx, :] = z_height[nlev_idx-1, :] + dz
    
    # Convert to km
    z_height /= 1000
    
    return z_height

# =========================
# Optimized data processing
# =========================
def process_variable_optimized(dataset, var_name, time_chunk_size=5, lat_chunk_size=30):
    """
    Optimized variable processing with larger chunks for better performance
    """
    # Check which dimension name exists in the file
    if 'valid_time' in dataset.dimensions:
        ntime = dataset.dimensions['valid_time'].size
    elif 'time' in dataset.dimensions:
        ntime = dataset.dimensions['time'].size
    else:
        raise ValueError("No time dimension found in the dataset")
        
    nlat = dataset.dimensions['latitude'].size
    nlev = dataset.dimensions['pressure_level'].size
    
    # Initialize array for zonal mean
    var_zm_tm = np.zeros((nlev, nlat), dtype=np.float32)
    
    # Process data in time and latitude chunks
    for time_i in range(0, ntime, time_chunk_size):
        time_end = min(time_i + time_chunk_size, ntime)
        
        for lat_i in range(0, nlat, lat_chunk_size):
            lat_end = min(lat_i + lat_chunk_size, nlat)
            
            try:
                # Read chunk of data
                var_chunk = dataset.variables[var_name][time_i:time_end, :, lat_i:lat_end, :]
                
                # Calculate zonal mean for this chunk
                var_zm_chunk = np.mean(var_chunk, axis=(0, 3))
                
                # Accumulate results with proper weighting
                chunk_weight = (time_end - time_i) / ntime
                var_zm_tm[:, lat_i:lat_end] += var_zm_chunk * chunk_weight
                
            except Exception as e:
                print(f"Error processing {var_name}: {e}")
                continue
    
    return var_zm_tm

# =========================
# Main - OPTIMIZED
# =========================
if __name__ == "__main__":
    start_time = time.time()
    
    print("Opening NetCDF:", nc_file)
    try:
        with nc.Dataset(nc_file, mode='r') as f:
            # Read basic dimensions
            lat = f.variables["latitude"][:]
            plev_hpa = f.variables["pressure_level"][:]
            pp_pa = plev_hpa * 100.0
            
            print("Reading and processing data with optimized chunks...")
            
            # Process variables with optimized chunk sizes
            print("Processing u variable...")
            u_zm_tm = process_variable_optimized(f, "u", time_chunk_size=5, lat_chunk_size=30)
            
            print("Processing t variable...")
            temp_zm_tm = process_variable_optimized(f, "t", time_chunk_size=5, lat_chunk_size=30)
            
            # Skip PV processing since we don't need it
            print("Skipping pv variable...")
            pv_zm_tm = np.zeros_like(u_zm_tm)
            
            print("Processing q variable...")
            try:
                q_zm_tm = process_variable_optimized(f, "q", time_chunk_size=5, lat_chunk_size=30)
            except:
                print("Warning: Could not process q variable, using zeros")
                q_zm_tm = np.zeros_like(u_zm_tm)
            
            nlev_len, ny_len = temp_zm_tm.shape
            
            # Calculate geopotential height for thermal tropopause
            print("Calculating geopotential height...")
            z_height = calculate_geopotential_height_vectorized(temp_zm_tm, pp_pa)
            
            print("Calculating tropopause using different methods...")
            
            # Calculate stability tropopause
            pStability = find_tropopause_stability(temp_zm_tm, pp_pa)
            stability_valid = np.sum(~np.isnan(pStability))
            print(f"Stability tropopause found at {stability_valid} of {ny_len} latitudes")
            
            # Calculate thermal tropopause with corrected algorithm
            print("Calculating thermal tropopause with corrected algorithm...")
            pThermal = find_thermal_tropopause_corrected(temp_zm_tm, z_height, pp_pa)
            
            # Prepare for plotting
            paxis = np.log10(pp_pa / 100)  # log10 of pressure in hPa
            ptop = 0.8  # log10(10 hPa)
            pbot = 3.0  # log10(1000 hPa)
            
            print("Creating plot...")
            
            # ---------- PLOT ----------
            plt.figure(figsize=(12, 7))
            plt.axis([lat[-1], lat[0] + 0.1, pbot, ptop])
            
            # Create legend
            legend_elements = [
                Line2D([0], [0], marker='s', color='green', lw=0, label='Stability Tropopause',
                       markersize=8, markeredgewidth=2),
                Line2D([0], [0], marker='o', color='red', lw=0, label='Thermal Tropopause',
                       markersize=8, markeredgewidth=2)
            ]
            plt.legend(handles=legend_elements, loc='upper right', fontsize=10, framealpha=0.8, facecolor='white')
            
            # Plot zonal wind contours
            CS = plt.contour(lat, paxis, u_zm_tm, linewidths=1, levels=[5,10,15,25,30,35,45,50,55,65,70,75], 
                             linestyles='solid', colors='black')
            CS = plt.contour(lat, paxis, u_zm_tm, linewidths=4, levels=[20,40,60,80], 
                             linestyles='solid', colors='black')
            plt.clabel(CS, fontsize=12, inline=1, fmt='%1.0f')
            
            # Plot temperature contours
            temp_c = temp_zm_tm - 273.16
            CS = plt.contour(lat, paxis, temp_c, linewidths=1, levels=[10,20,30,40], 
                             linestyles='solid', colors='red')
            CS = plt.contour(lat, paxis, temp_c, linewidths=3, levels=[0], 
                             linestyles='dashed', colors='c')
            plt.clabel(CS, fontsize=14, inline=1, fmt='%1.0f')
            
            # Fill temperature regions
            plt.contourf(lat, paxis, temp_c, levels=[-120,-80.1], colors='mediumorchid', alpha=0.7) 
            plt.contourf(lat, paxis, temp_c, levels=[-79.9,-60], colors='lightskyblue', alpha=0.7) 
            plt.contourf(lat, paxis, temp_c, levels=[10,60], colors='lightsalmon', alpha=0.7)  
            plt.contourf(lat, paxis, temp_c, levels=[-60,0], colors='lightcyan', alpha=0.7) 
            
            # Plot all tropopause types
            valid_lat_mask = np.abs(lat) < 88.0
            
            # Stability tropopause
            stab_mask = valid_lat_mask & ~np.isnan(pStability)
            plt.plot(lat[stab_mask], np.log10(pStability[stab_mask]/100), "s", 
                     markersize=6, color='green', alpha=0.8)
            
            # Thermal tropopause - THIS IS THE LINE WITH THE MASK
            thermal_mask = valid_lat_mask & ~np.isnan(pThermal)
            print(f"Plotting thermal tropopause at {np.sum(thermal_mask)} latitudes")
            plt.plot(lat[thermal_mask], np.log10(pThermal[thermal_mask]/100), "o", 
                     markersize=6, color='red', alpha=0.8)
            
            # Final plot formatting
            plt.xticks(np.arange(lat[-1], lat[0] + 0.1, 15), fontsize=15)
            plt.yticks(np.arange(pbot, ptop, -1), fontsize=15)
            
            ax = plt.gca()
            ax.axes.yaxis.set_ticklabels([])
            
            # Add pressure labels
            pressure_labels = [
                (3, "1000", lat[-1]-14),
                (2.02, "100", lat[-1]-11),
                (1.02, "10", lat[-1]-8),
                (2.497, "300", lat[-1]-11),
                (1.497, "30", lat[-1]-8),
                (2.72, "500", lat[-1]-11),
                (1.72, "50", lat[-1]-8),
                (2.32, "200", lat[-1]-11),
                (1.32, "20", lat[-1]-8)
            ]
            
            for y, text, x_pos in pressure_labels:
                plt.text(x_pos, y, text, fontsize=15)
            
            # Title and labels
            plt.title('Monthly/zonal-mean zonal wind (m/s), temperature (C)\n'
                      'Stability (green), Thermal (red)', 
                      fontsize=10)
            
            plt.text(80, 3.20, "ERA5", fontsize=8)
            plt.text(80, 3.25, "Tropopause Analysis", fontsize=8)
            
            plt.xlabel('latitude [degrees north]', fontsize=16)
            plt.text(lat[-1]-20, 2.3, 'pressure (hPa)', rotation=90, va='center', fontsize=16)
            
            # Save and show
            outfile = os.path.join(direcOutput, "tropopause_stability_thermal_comparison_optimized.png")
            plt.savefig(outfile, dpi=300, bbox_inches='tight')
            plt.show()
            plt.close()
            
            elapsed_time = time.time() - start_time
            print(f"Saved: {outfile}")
            print(f"Execution time: {elapsed_time:.2f} seconds")

    except Exception as e:
        print(f"Error opening or processing file: {e}")
        import traceback
        traceback.print_exc()

    print("Processing completed.")
