import numpy as np
import netCDF4 as nc
from netCDF4 import num2date
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
import cartopy.feature as cfeature
import matplotlib.colors as mcolors
from scipy.interpolate import griddata
from scipy.ndimage import gaussian_filter
import geopandas as gpd  # <-- added

# Constants
PVU_CONVERSION = 1e6
GRAVITY = 9.80665  # m/s^2

# Paths (edit if needed)
direcInput = "C:/Users/moham/OneDrive/Documents/stage"
direcOutput = "C:/Users/moham/OneDrive/Documents/stage"

# Colormap
colors = ['darkviolet', 'blue', 'dodgerblue', 'cyan', 'lime', 'yellow', 'orange', 'red']
cmap = mcolors.LinearSegmentedColormap.from_list('altitude_cmap', colors, N=256)

print("Opening the NetCDF file...")
with nc.Dataset(direcInput + "/629f42bac50cf310898d868e4fd1d664.nc", "r") as f:
    lat = f.variables["latitude"][:]
    lon = f.variables["longitude"][:]
    time_var = f.variables["valid_time"]
    times = num2date(time_var[:], units=time_var.units)
    p_levels = f.variables["pressure_level"][:]
    print(f"Pressure levels available: {p_levels} hPa")

    lon_corrected = np.where(lon > 180, lon - 360, lon)

    # region
    lat_min, lat_max = 20, 55
    lon_min, lon_max = -30, 30

    lat_indices = np.where((lat >= lat_min) & (lat <= lat_max))[0]
    lon_indices = np.where((lon_corrected >= lon_min) & (lon_corrected <= lon_max))[0]

    if lat_indices.size == 0 or lon_indices.size == 0:
        raise ValueError("No grid points found in requested region. Check lat/lon ranges.")

    lat_region = lat[lat_indices]
    lon_region = lon_corrected[lon_indices]

    lat_order = np.argsort(lat_region)
    lon_order = np.argsort(lon_region)
    lat_region = lat_region[lat_order]
    lon_region = lon_region[lon_order]

    print(f"Europe + Morocco region: {len(lat_region)} x {len(lon_region)} points")
    print(f"Range: {lat_region.min():.1f}–{lat_region.max():.1f}°N, {lon_region.min():.1f}–{lon_region.max():.1f}°E")

    for it in range(min(16, len(times))):
        print(f"\nProcessing timestep {it+1}...")

        pv_full = f.variables["pv"][it, :, :, :][...]
        z_full  = f.variables["z"][it, :, :, :][...]

        pv_sub = np.take(np.take(pv_full, lat_indices, axis=1), lon_indices, axis=2)
        z_sub  = np.take(np.take(z_full,  lat_indices, axis=1), lon_indices, axis=2)

        pv_data = pv_sub[:, lat_order, :][:, :, lon_order]
        z_data  = z_sub[:,  lat_order, :][:, :, lon_order]

        z_height_dam = (z_data / GRAVITY) / 10.0

        print(f"PV range in region: {np.nanmin(pv_data):.6f} to {np.nanmax(pv_data):.6f}")
        print(f"PV range in PVU: {np.nanmin(pv_data)*1e6:.2f} to {np.nanmax(pv_data)*1e6:.2f} PVU")

        pv_target = 1.5e-6
        ny, nx = len(lat_region), len(lon_region)
        z_15pvu = np.full((ny, nx), np.nan)

        valid_count = 0
        levels = pv_data.shape[0]

        for j in range(ny):
            for k in range(nx):
                pv_profile = pv_data[:, j, k]
                z_profile  = z_height_dam[:, j, k]

                if not np.any(np.isfinite(pv_profile)):
                    continue

                above = pv_profile > pv_target
                transition = np.where(np.diff(above.astype(int)) > 0)[0]
                got = False
                if transition.size > 0:
                    idx = transition[0]
                    if idx + 1 < levels:
                        pv1, pv2 = pv_profile[idx], pv_profile[idx+1]
                        z1, z2   = z_profile[idx], z_profile[idx+1]
                        if np.isfinite(pv1) and np.isfinite(pv2) and pv1 != pv2 and pv1 < pv_target < pv2:
                            frac = (pv_target - pv1) / (pv2 - pv1)
                            z_15pvu[j, k] = z1 + frac * (z2 - z1)
                            valid_count += 1
                            got = True

                if not got:
                    cidx = np.nanargmin(np.abs(pv_profile - pv_target))
                    if np.isfinite(pv_profile[cidx]) and np.isfinite(z_profile[cidx]):
                        z_15pvu[j, k] = z_profile[cidx]
                        valid_count += 1

        print(f"Found {valid_count} valid points for PV=1.5 PVU")

        if valid_count < 30:
            print("Not enough points -> skipping this timestep.")
            continue

        z_15pvu[(z_15pvu < 600) | (z_15pvu > 2000)] = np.nan

        lon_grid, lat_grid = np.meshgrid(lon_region, lat_region)
        valid_mask = np.isfinite(z_15pvu)
        lon_valid = lon_grid[valid_mask]
        lat_valid = lat_grid[valid_mask]
        z_valid   = z_15pvu[valid_mask]

        if z_valid.size == 0:
            print("No valid values after filtering -> skip.")
            continue

        # --- improved interpolation (linear + nearest fill + smoothing) ---
        lon_new = np.linspace(lon_min, lon_max, 200)
        lat_new = np.linspace(lat_min, lat_max, 200)
        Lon_new, Lat_new = np.meshgrid(lon_new, lat_new)

        Zgrid_lin = griddata((lon_valid, lat_valid), z_valid,
                             (Lon_new, Lat_new), method='linear')
        Zgrid_near = griddata((lon_valid, lat_valid), z_valid,
                              (Lon_new, Lat_new), method='nearest')
        Zgrid = np.where(np.isnan(Zgrid_lin), Zgrid_near, Zgrid_lin)

        # Gaussian smoothing
        Zgrid = gaussian_filter(Zgrid, sigma=1.5)

        vals = Zgrid[np.isfinite(Zgrid)]
        print(f"Geopotential height at PV=1.5 PVU range: {vals.min():.1f} to {vals.max():.1f} dam")

        # --- plotting ---
        fig = plt.figure(figsize=(14, 12))
        ax = plt.axes(projection=ccrs.PlateCarree())
        ax.set_extent([lon_min, lon_max, lat_min, lat_max], crs=ccrs.PlateCarree())

        ax.add_feature(cfeature.COASTLINE, linewidth=0.8)
        ax.add_feature(cfeature.OCEAN, color='lightblue', alpha=0.3)
        ax.add_feature(cfeature.LAND, color='lightgray', alpha=0.2)

        gl = ax.gridlines(crs=ccrs.PlateCarree(), draw_labels=True, linewidth=0.5,
                          color='gray', alpha=0.5, linestyle='--')
        gl.top_labels = False
        gl.right_labels = False
        gl.xlabel_style = {'size': 8}
        gl.ylabel_style = {'size': 8}

        zmin, zmax = np.nanmin(Zgrid), np.nanmax(Zgrid)
        contour_interval = 50
        zmin_rounded = np.floor(zmin / contour_interval) * contour_interval
        zmax_rounded = np.ceil(zmax / contour_interval) * contour_interval
        contour_levels = np.arange(zmin_rounded, zmax_rounded + contour_interval, contour_interval)
        norm = mcolors.Normalize(vmin=zmin_rounded, vmax=zmax_rounded)

        cf = ax.contourf(Lon_new, Lat_new, Zgrid,
                         levels=contour_levels, cmap=cmap, norm=norm, extend='both')
        cs = ax.contour(Lon_new, Lat_new, Zgrid,
                        levels=contour_levels, colors='k', linewidths=0.7)

        label_levels = [lev for lev in contour_levels if (lev % 100) == 0]
        ax.clabel(cs, levels=label_levels, fmt='%d', fontsize=8)

        # --- Morocco shapefile overlay ---
        try:
            mor = gpd.read_file(r"C:/Users/moham/OneDrive/Documents/stage/Morocco_ADM0_simplified.simplified.geojson")
            for geometry in mor["geometry"]:
                ax.add_geometries([geometry], crs=ccrs.PlateCarree(),
                                  facecolor='none', edgecolor='black', linewidth=1.5, zorder=5)
        except Exception as e:
            print("    Morocco shapefile not loaded:", e)

        # --- Correct time handling ---
        time_dt = times[it]
        time_str = time_dt.strftime('%Y-%m-%d %H:%M UTC')

        plt.title(f'Geopotential Height at PV=1.5 PVU - {time_str}\nRegion: Europe + Morocco',
                  fontsize=14, pad=20)

        cbar = plt.colorbar(cf, ax=ax, orientation='horizontal', pad=0.05, aspect=30)
        cbar.set_label('Geopotential Height (dam)', fontsize=11)

        plt.savefig(direcOutput + f"/map_europe_morocco_pv15_{it:02d}.png", dpi=300, bbox_inches='tight')
        plt.show()
        plt.close()

