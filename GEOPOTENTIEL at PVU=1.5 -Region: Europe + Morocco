import numpy as np
import netCDF4 as nc
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
import cartopy.feature as cfeature
from datetime import datetime
import time as timemod
import matplotlib.colors as mcolors
from scipy.interpolate import griddata
from scipy.ndimage import gaussian_filter

# Conversion factor: 1 PVU = 10^-6 K m² kg⁻¹ s⁻¹
PVU_CONVERSION = 1e6
# Conversion factor: geopotential to geopotential height (divide by gravity, 9.80665 m/s²)
GRAVITY = 9.80665

# Directory setup
direcInput = "C:/Users/moham/OneDrive/Documents/stage"
direcOutput = "C:/Users/moham/OneDrive/Documents/stage"

# Create a custom colormap (cold → hot)
colors = ['darkviolet', 'blue', 'dodgerblue', 'cyan', 'lime', 'yellow', 'orange', 'red']
cmap = mcolors.LinearSegmentedColormap.from_list('altitude_cmap', colors, N=256)

# Open the NetCDF file
print("Opening the NetCDF file...")
with nc.Dataset(direcInput+"/78fecb096216f2852181c4618c5e8cbb.nc", mode='r') as f:
    # Read data
    lat = f.variables["latitude"][:] 
    lon = f.variables["longitude"][:] 
    time = f.variables["valid_time"][:]
    p_levels = f.variables["pressure_level"][:]  # Pressure levels in hPa

    print(f"Original dimensions: lat={len(lat)}, lon={len(lon)}")

    # Convert longitudes from 0-360° to -180-180°
    lon_corrected = np.where(lon > 180, lon - 360, lon)
    
    # FULL REGION OF Morocco and Europe
    lat_min, lat_max = 20, 55   # From the southern Sahara to the northern Europe
    lon_min, lon_max = -30, 30  # From the Atlantic to the eastern border of Europe
    
    # Find the corresponding indices
    lat_indices = np.where((lat >= lat_min) & (lat <= lat_max))[0]
    lon_indices = np.where((lon_corrected >= lon_min) & (lon_corrected <= lon_max))[0]
    
    # Select the data subsets
    lat_region = lat[lat_indices]
    lon_region = lon_corrected[lon_indices]

    print(f"Europe + Morocco region: {len(lat_region)}x{len(lon_region)} points")
    print(f"Range: {lat_region.min():.1f}°N to {lat_region.max():.1f}°N, {lon_region.min():.1f}°E to {lon_region.max():.1f}°E")

    # Create maps
    for i in range(min(16, len(time))):
        start_time = timemod.time()
        print(f"\nProcessing timestep {i+1}...")
        
        # Read data
        pv_data = f.variables["pv"][i, :, lat_indices[0]:lat_indices[-1]+1, lon_indices[0]:lon_indices[-1]+1]
        pv_time = pv_data * PVU_CONVERSION
        
        # Read geopotential data (convert to geopotential height in meters, then to decameters)
        z_data = f.variables["z"][i, :, lat_indices[0]:lat_indices[-1]+1, lon_indices[0]:lon_indices[-1]+1]
        z_height_m = z_data / GRAVITY  # Convert to meters
        z_height_dam = z_height_m / 10  # Convert to decameters
        
        # Search for the PVU=1.5 surface and get the corresponding geopotential height
        pvu_target = 1.5
        z_15pvu = np.full((len(lat_region), len(lon_region)), np.nan)
        
        for lat_idx in range(len(lat_region)):
            for lon_idx in range(len(lon_region)):
                pv_profile = pv_time[:, lat_idx, lon_idx]
                
                if np.any(np.isfinite(pv_profile)):
                    diff = np.abs(pv_profile - pvu_target)
                    level_idx = np.argmin(diff)
                    
                    if diff[level_idx] < 0.5:
                        z_15pvu[lat_idx, lon_idx] = z_height_dam[level_idx, lat_idx, lon_idx]
        
        # Prepare data for interpolation
        lon_grid, lat_grid = np.meshgrid(lon_region, lat_region)
        valid_mask = ~np.isnan(z_15pvu)
        valid_points = np.column_stack((lon_grid[valid_mask], lat_grid[valid_mask]))
        valid_values = z_15pvu[valid_mask]
        
        if len(valid_values) < 30:
            print(f"Not enough valid points ({len(valid_values)})")
            continue
        
        # Create a grid for interpolation
        lon_fine = np.linspace(lon_min, lon_max, 80)
        lat_fine = np.linspace(lat_min, lat_max, 80)
        lon_fine_grid, lat_fine_grid = np.meshgrid(lon_fine, lat_fine)
        
        # Interpolation
        z_interp = griddata(valid_points, valid_values, 
                           (lon_fine_grid, lat_fine_grid), method='linear')
        
        # Smoothing
        z_interp = gaussian_filter(z_interp, sigma=1.5)
        
        # Create figure with Cartopy
        fig = plt.figure(figsize=(14, 12))
        ax = plt.axes(projection=ccrs.PlateCarree())
        
        # Define map extent (Europe + Morocco)
        ax.set_extent([lon_min, lon_max, lat_min, lat_max], crs=ccrs.PlateCarree())
        
        # Add geographical features without borders
        ax.add_feature(cfeature.COASTLINE, linewidth=0.8)
        ax.add_feature(cfeature.OCEAN, color='lightblue', alpha=0.3)
        ax.add_feature(cfeature.LAND, color='lightgray', alpha=0.2)
        
        # Add gridlines
        gl = ax.gridlines(crs=ccrs.PlateCarree(), draw_labels=True,
                         linewidth=0.5, color='gray', alpha=0.5, linestyle='--')
        gl.top_labels = False
        gl.right_labels = False
        gl.xlabel_style = {'size': 8}
        gl.ylabel_style = {'size': 8}
        
        # Determine contour levels with 100 dam interval
        z_min, z_max = np.nanmin(valid_values), np.nanmax(valid_values)
        # Round to nearest 100 dam
        z_min_rounded = np.floor(z_min / 100) * 100
        z_max_rounded = np.ceil(z_max / 100) * 100
        contour_levels = np.arange(z_min_rounded, z_max_rounded + 100, 100)
        
        # Create a normalized colormap based on the data range
        norm = mcolors.Normalize(vmin=z_min_rounded, vmax=z_max_rounded)
        
        # Plot contours with 100 dam interval and different colors
        cs = ax.contour(lon_fine_grid, lat_fine_grid, z_interp,
                       levels=contour_levels, linewidths=2.5,
                       cmap=cmap, norm=norm, transform=ccrs.PlateCarree())
        
        # Add labels to all contours (every 100 dam)
        ax.clabel(cs, fmt='%d dam', fontsize=8, colors='black')
        
        # Title
        time_val = time[i]
        time_dt = datetime.fromtimestamp(time_val)
        time_str = time_dt.strftime('%Y-%m-%d %H:%M UTC')
        
        plt.title(f'Geopotential Height at PVU=1.5 - {time_str}\nRegion: Europe + Morocco', 
                 fontsize=14, pad=20)
        
        # Add colorbar
        cbar = plt.colorbar(plt.cm.ScalarMappable(norm=norm, cmap=cmap),
                           ax=ax, orientation='horizontal', pad=0.05, aspect=30)
        cbar.set_label('Geopotential Height (dam)', fontsize=11)
        
        # Save the figure
        plt.savefig(direcOutput + f"/map_europe_morocco_cartopy_{i:02d}.png", dpi=300, bbox_inches='tight')
        plt.show()
        plt.close()
        
        end_time = timemod.time()
        print(f"Map {i+1} generated in {end_time - start_time:.1f} seconds")

print("All Europe + Morocco maps have been generated with Cartopy!")
